/**
 * @file display.c
 * @brief OLED SSD1306 display driver implementation
 */

#include "driver/i2c.h"
#include "esp_log.h"
#include <string.h>


#include "config.h"
#include "display.h"
#include "mode_mecanum.h"
#include "mode_menu.h"
#include "mode_rc.h"
#include "mode_settings.h"
#include "mode_voice.h"
#include "types.h"
#include "ui_common.h"


static const char *TAG = "DISPLAY";

// SSD1306 commands
#define SSD1306_CMD_DISPLAY_OFF 0xAE
#define SSD1306_CMD_DISPLAY_ON 0xAF
#define SSD1306_CMD_SET_CONTRAST 0x81
#define SSD1306_CMD_SET_PAGE 0xB0
#define SSD1306_CMD_SET_COL_LOW 0x00
#define SSD1306_CMD_SET_COL_HIGH 0x10

// Display buffer
static uint8_t s_framebuffer[OLED_WIDTH * OLED_HEIGHT / 8];

// ============================================================
// I2C COMMUNICATION
// ============================================================
static esp_err_t i2c_write_cmd(uint8_t cmd) {
  uint8_t data[2] = {0x00, cmd}; // Co=0, D/C#=0 (command)
  return i2c_master_write_to_device(OLED_I2C_NUM, OLED_ADDRESS, data,
                                    sizeof(data), pdMS_TO_TICKS(100));
}

static esp_err_t i2c_write_data(const uint8_t *data, size_t len) {
  uint8_t *buf = malloc(len + 1);
  if (!buf)
    return ESP_ERR_NO_MEM;

  buf[0] = 0x40; // Co=0, D/C#=1 (data)
  memcpy(buf + 1, data, len);

  esp_err_t ret = i2c_master_write_to_device(OLED_I2C_NUM, OLED_ADDRESS, buf,
                                             len + 1, pdMS_TO_TICKS(100));
  free(buf);
  return ret;
}

// ============================================================
// INITIALIZATION
// ============================================================
void display_init(void) {
  // Configure I2C
  i2c_config_t conf = {
      .mode = I2C_MODE_MASTER,
      .sda_io_num = PIN_OLED_SDA,
      .scl_io_num = PIN_OLED_SCL,
      .sda_pullup_en = GPIO_PULLUP_ENABLE,
      .scl_pullup_en = GPIO_PULLUP_ENABLE,
      .master.clk_speed = OLED_I2C_FREQ,
  };
  ESP_ERROR_CHECK(i2c_param_config(OLED_I2C_NUM, &conf));
  ESP_ERROR_CHECK(i2c_driver_install(OLED_I2C_NUM, I2C_MODE_MASTER, 0, 0, 0));

  // SSD1306 initialization sequence
  const uint8_t init_cmds[] = {
      0xAE,       // Display off
      0xD5, 0x80, // Set display clock
      0xA8, 0x3F, // Set multiplex ratio (64-1)
      0xD3, 0x00, // Set display offset
      0x40,       // Set start line
      0x8D, 0x14, // Enable charge pump
      0x20, 0x00, // Set memory mode (horizontal)
      0xA1,       // Segment remap
      0xC8,       // COM scan direction
      0xDA, 0x12, // Set COM pins
      0x81, 0xFF, // Set contrast (max)
      0xD9, 0xF1, // Set precharge
      0xDB, 0x40, // Set VCOMH
      0xA4,       // Display from RAM
      0xA6,       // Normal display (not inverted)
      0xAF,       // Display on
  };

  for (int i = 0; i < sizeof(init_cmds); i++) {
    i2c_write_cmd(init_cmds[i]);
  }

  // Clear framebuffer
  memset(s_framebuffer, 0, sizeof(s_framebuffer));

  ESP_LOGI(TAG, "OLED initialized");
}

// ============================================================
// FRAMEBUFFER OPERATIONS
// ============================================================
void display_clear(void) { memset(s_framebuffer, 0, sizeof(s_framebuffer)); }

static void display_flush(void) {
  for (int page = 0; page < 8; page++) {
    i2c_write_cmd(SSD1306_CMD_SET_PAGE | page);
    i2c_write_cmd(SSD1306_CMD_SET_COL_LOW | 0);
    i2c_write_cmd(SSD1306_CMD_SET_COL_HIGH | 0);
    i2c_write_data(&s_framebuffer[page * OLED_WIDTH], OLED_WIDTH);
  }
}

// Drawing functions
void display_set_pixel(int x, int y, bool on) {
  if (x < 0 || x >= OLED_WIDTH || y < 0 || y >= OLED_HEIGHT)
    return;

  int idx = x + (y / 8) * OLED_WIDTH;
  if (on) {
    s_framebuffer[idx] |= (1 << (y % 8));
  } else {
    s_framebuffer[idx] &= ~(1 << (y % 8));
  }
}

void display_draw_char(int x, int y, char c) {
  // Simple 5x7 font rendering - using basic font
  extern const uint8_t font5x7[];
  if (c < 32 || c > 126)
    c = ' ';

  const uint8_t *glyph = &font5x7[(c - 32) * 5];
  for (int col = 0; col < 5; col++) {
    uint8_t line = glyph[col];
    for (int row = 0; row < 7; row++) {
      display_set_pixel(x + col, y + row, (line >> row) & 1);
    }
  }
}

void display_draw_string(int x, int y, const char *str) {
  while (*str) {
    display_draw_char(x, y, *str++);
    x += 6;
  }
}

void display_fill_rect(int x, int y, int w, int h, bool on) {
  for (int i = x; i < x + w; i++) {
    for (int j = y; j < y + h; j++) {
      display_set_pixel(i, j, on);
    }
  }
}

void display_draw_rect(int x, int y, int w, int h) {
  for (int i = x; i < x + w; i++) {
    display_set_pixel(i, y, true);
    display_set_pixel(i, y + h - 1, true);
  }
  for (int j = y; j < y + h; j++) {
    display_set_pixel(x, j, true);
    display_set_pixel(x + w - 1, j, true);
  }
}

// ============================================================
// SPLASH SCREEN
// ============================================================
void display_splash(void) {
  display_clear();
  display_draw_string(20, 20, "MINI OS v1");
  display_draw_string(25, 35, "ESP32-S3");
  display_draw_string(15, 50, "Mecanum Robot");
  display_flush();
}

// ============================================================
// SET BRIGHTNESS
// ============================================================
void display_set_brightness(uint8_t brightness) {
  i2c_write_cmd(SSD1306_CMD_SET_CONTRAST);
  i2c_write_cmd(brightness);
}

// ============================================================
// UPDATE DISPLAY
// ============================================================
void display_update(void) {
  display_clear();

  switch (g_ctx.current_state) {
  case STATE_MAIN_MENU:
    mode_menu_draw();
    break;
  case STATE_MODE_MECANUM:
    mode_mecanum_draw();
    break;
  case STATE_MODE_RC:
    mode_rc_draw();
    break;
  case STATE_MODE_VOICE:
    mode_voice_draw();
    break;
  case STATE_MODE_SETTINGS:
    mode_settings_draw();
    break;
  }

  display_flush();
}

// ============================================================
// 5x7 FONT DATA
// ============================================================
const uint8_t font5x7[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, // Space
    0x00, 0x00, 0x5F, 0x00, 0x00, // !
    0x00, 0x07, 0x00, 0x07, 0x00, // "
    0x14, 0x7F, 0x14, 0x7F, 0x14, // #
    0x24, 0x2A, 0x7F, 0x2A, 0x12, // $
    0x23, 0x13, 0x08, 0x64, 0x62, // %
    0x36, 0x49, 0x55, 0x22, 0x50, // &
    0x00, 0x05, 0x03, 0x00, 0x00, // '
    0x00, 0x1C, 0x22, 0x41, 0x00, // (
    0x00, 0x41, 0x22, 0x1C, 0x00, // )
    0x08, 0x2A, 0x1C, 0x2A, 0x08, // *
    0x08, 0x08, 0x3E, 0x08, 0x08, // +
    0x00, 0x50, 0x30, 0x00, 0x00, // ,
    0x08, 0x08, 0x08, 0x08, 0x08, // -
    0x00, 0x60, 0x60, 0x00, 0x00, // .
    0x20, 0x10, 0x08, 0x04, 0x02, // /
    0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
    0x00, 0x42, 0x7F, 0x40, 0x00, // 1
    0x42, 0x61, 0x51, 0x49, 0x46, // 2
    0x21, 0x41, 0x45, 0x4B, 0x31, // 3
    0x18, 0x14, 0x12, 0x7F, 0x10, // 4
    0x27, 0x45, 0x45, 0x45, 0x39, // 5
    0x3C, 0x4A, 0x49, 0x49, 0x30, // 6
    0x01, 0x71, 0x09, 0x05, 0x03, // 7
    0x36, 0x49, 0x49, 0x49, 0x36, // 8
    0x06, 0x49, 0x49, 0x29, 0x1E, // 9
    0x00, 0x36, 0x36, 0x00, 0x00, // :
    0x00, 0x56, 0x36, 0x00, 0x00, // ;
    0x00, 0x08, 0x14, 0x22, 0x41, // <
    0x14, 0x14, 0x14, 0x14, 0x14, // =
    0x41, 0x22, 0x14, 0x08, 0x00, // >
    0x02, 0x01, 0x51, 0x09, 0x06, // ?
    0x32, 0x49, 0x79, 0x41, 0x3E, // @
    0x7E, 0x11, 0x11, 0x11, 0x7E, // A
    0x7F, 0x49, 0x49, 0x49, 0x36, // B
    0x3E, 0x41, 0x41, 0x41, 0x22, // C
    0x7F, 0x41, 0x41, 0x22, 0x1C, // D
    0x7F, 0x49, 0x49, 0x49, 0x41, // E
    0x7F, 0x09, 0x09, 0x01, 0x01, // F
    0x3E, 0x41, 0x41, 0x51, 0x32, // G
    0x7F, 0x08, 0x08, 0x08, 0x7F, // H
    0x00, 0x41, 0x7F, 0x41, 0x00, // I
    0x20, 0x40, 0x41, 0x3F, 0x01, // J
    0x7F, 0x08, 0x14, 0x22, 0x41, // K
    0x7F, 0x40, 0x40, 0x40, 0x40, // L
    0x7F, 0x02, 0x04, 0x02, 0x7F, // M
    0x7F, 0x04, 0x08, 0x10, 0x7F, // N
    0x3E, 0x41, 0x41, 0x41, 0x3E, // O
    0x7F, 0x09, 0x09, 0x09, 0x06, // P
    0x3E, 0x41, 0x51, 0x21, 0x5E, // Q
    0x7F, 0x09, 0x19, 0x29, 0x46, // R
    0x46, 0x49, 0x49, 0x49, 0x31, // S
    0x01, 0x01, 0x7F, 0x01, 0x01, // T
    0x3F, 0x40, 0x40, 0x40, 0x3F, // U
    0x1F, 0x20, 0x40, 0x20, 0x1F, // V
    0x7F, 0x20, 0x18, 0x20, 0x7F, // W
    0x63, 0x14, 0x08, 0x14, 0x63, // X
    0x03, 0x04, 0x78, 0x04, 0x03, // Y
    0x61, 0x51, 0x49, 0x45, 0x43, // Z
    0x00, 0x00, 0x7F, 0x41, 0x41, // [
    0x02, 0x04, 0x08, 0x10, 0x20, // backslash
    0x41, 0x41, 0x7F, 0x00, 0x00, // ]
    0x04, 0x02, 0x01, 0x02, 0x04, // ^
    0x40, 0x40, 0x40, 0x40, 0x40, // _
    0x00, 0x01, 0x02, 0x04, 0x00, // `
    0x20, 0x54, 0x54, 0x54, 0x78, // a
    0x7F, 0x48, 0x44, 0x44, 0x38, // b
    0x38, 0x44, 0x44, 0x44, 0x20, // c
    0x38, 0x44, 0x44, 0x48, 0x7F, // d
    0x38, 0x54, 0x54, 0x54, 0x18, // e
    0x08, 0x7E, 0x09, 0x01, 0x02, // f
    0x08, 0x14, 0x54, 0x54, 0x3C, // g
    0x7F, 0x08, 0x04, 0x04, 0x78, // h
    0x00, 0x44, 0x7D, 0x40, 0x00, // i
    0x20, 0x40, 0x44, 0x3D, 0x00, // j
    0x00, 0x7F, 0x10, 0x28, 0x44, // k
    0x00, 0x41, 0x7F, 0x40, 0x00, // l
    0x7C, 0x04, 0x18, 0x04, 0x78, // m
    0x7C, 0x08, 0x04, 0x04, 0x78, // n
    0x38, 0x44, 0x44, 0x44, 0x38, // o
    0x7C, 0x14, 0x14, 0x14, 0x08, // p
    0x08, 0x14, 0x14, 0x18, 0x7C, // q
    0x7C, 0x08, 0x04, 0x04, 0x08, // r
    0x48, 0x54, 0x54, 0x54, 0x20, // s
    0x04, 0x3F, 0x44, 0x40, 0x20, // t
    0x3C, 0x40, 0x40, 0x20, 0x7C, // u
    0x1C, 0x20, 0x40, 0x20, 0x1C, // v
    0x3C, 0x40, 0x30, 0x40, 0x3C, // w
    0x44, 0x28, 0x10, 0x28, 0x44, // x
    0x0C, 0x50, 0x50, 0x50, 0x3C, // y
    0x44, 0x64, 0x54, 0x4C, 0x44, // z
    0x00, 0x08, 0x36, 0x41, 0x00, // {
    0x00, 0x00, 0x7F, 0x00, 0x00, // |
    0x00, 0x41, 0x36, 0x08, 0x00, // }
    0x08, 0x08, 0x2A, 0x1C, 0x08, // ~
};
